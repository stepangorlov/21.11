Объяснение условия:
start >= last_end проверяет, что начало текущего интервала больше или равно времени окончания последнего выбранного интервала
Это гарантирует, что интервалы не пересекаются
Если условие выполняется, добавляем интервал в результат и обновляем last_end
Почему именно такое условие:
last_end - время окончания последнего выбранного интервала
start - время начала текущего рассматриваемого интервала
Логика:
Если start >= last_end, значит текущий интервал начинается после или в момент окончания последнего выбранного
Это гарантирует, что интервалы не пересекаются
Временная сложность:
Сортировка: O(n log n) - доминирующая операция
Проход по интервалам: O(n) - один проход по отсортированному списку
Общая временная сложность: O(n logn)+O(n)=O(n logn)
Пространственная сложность: O(n)
result список может содержать до n интервалов
Дополнительная память: O(1) для переменных
Разбор сложности:
intervals.sort(key=lambda x: x[1]) - O(n log n)
Используется Timsort (гибридный алгоритм Python)
В худшем случае: O(n log n)
Это доминирующая операция
Цикл for start, end in intervals: - O(n)
Проходим по всем n интервалам
Каждая итерация: O(1) операций
Операции внутри цикла:
if start >= last_end - O(1)
result.append() - O(1)* (амортизированно)
last_end = end - O(1)
Контрольный вопрос:
Почему мы сортируем по времени окончания, а не по времени начала?
Ответ: Сортировка по времени окончания является оптимальной стратегией, потому что:
-Выбор интервала, который заканчивается раньше, оставляет больше времени для выбора последующих интервалов
-Это гарантирует максимальное количество непересекающихся интервалов
-Если бы мы сортировали по времени начала, могли бы выбрать длинные интервалы, которые "блокируют" возможность выбора нескольких коротких
